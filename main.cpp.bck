#include <iostream>
#include <fstream>
#include <cstring>
#include <sstream>
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include "src/Renderer.h"
#include "src/Tests/TestClearColor.h"
//#include "src/IndexBuffer.h"
//#include "src/VertexArray.h"
//#include "src/Shader.h"

int main(void)
{
    
    int width = 800;
    int height = 680;
    bool PixelMode = true;
    float ScalePixle = 1.0f;
    float ScaleFactor[2] = {0.0f,0.0f};
    float ScaleBuffer;

    ScaleBuffer = (float)width/(float)height;

    if(ScaleBuffer < 1.0f){
        ScaleBuffer = (float)height/(float)width;
        ScaleFactor[0] = 1.0f;
        ScaleFactor[1] = ScaleBuffer;
    } else {
        ScaleFactor[0] = ScaleBuffer;
        ScaleFactor[1] = 1.0f;
    }

    std::cout << ScaleFactor[0] << std::endl;
    std::cout << ScaleFactor[1] << std::endl;

    glm::mat4 proj;
    // View can be camera
    glm::mat4 view = glm::translate(glm::mat4(1.0f),glm::vec3(0,0,0));
    // Modles position
    //glm::mat4 modle = glm::translate(glm::mat4(1.0f), glm::vec3(100,100,0));

    if(PixelMode){

        proj = glm::ortho(0.0f, (float)width/ScalePixle, 0.0f, (float)height/ScalePixle, -1.0f, 1.0f);


    } else{

        proj = glm::ortho(-ScaleFactor[0]/ScalePixle, ScaleFactor[0]/ScalePixle, -ScaleFactor[1]/ScalePixle, ScaleFactor[1]/ScalePixle, -1.0f, 1.0f);

    }




    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit()) {
        return -1;
    }

    //Set OpenGL Version

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(width, height, "DUMB OPENGL WINDOW", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }
    /* Make the window's context current */
    glfwMakeContextCurrent(window);
    // Enables V sync
    glfwSwapInterval(1);

    /* setup GLEW */
    if(glewInit() != GLEW_OK){
        std::cout << "ERROR..." << std::endl;
        return -1;
    }

    std::cout << glGetString(GL_VERSION) << std::endl;
    std::cout << "GL_SHADING_LANGUAGE_VERSION: " << glGetString (GL_SHADING_LANGUAGE_VERSION) << std::endl;
    
    

  
    //Objects in open GL
    /* Draws simple triangle */

    // Adding texture cordinats to the rects positions
    /*float poss[16] = {
                    // set position values for vertexes (more info can be added)
                    -0.5f, -0.5f, 0.0f, 0.0f,
                     0.5f, -0.5f, 1.0f, 0.0f,
                     0.5f, 0.5f, 1.0f, 1.0f,
                     -0.5f, 0.5f, 0.0f, 1.0f,
                     };
    */
    
    // could be used to define modle size and not its poss
    float poss[16] = {
                    // set position values for vertexes (more info can be added)
                    0.0f, 0.0f, 0.0f, 0.0f,
                     200.0f, 0.0f, 1.0f, 0.0f,
                     200.0f, 200.0f, 1.0f, 1.0f,
                     0.0f, 200.0f, 0.0f, 1.0f,
                     };

    unsigned int SqIndex[6] ={
            //tells what points to draw in what order
            0,1,2,
            2,3,0
    };


    GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));
    GLCall(glEnable(GL_BLEND));


    //Take info and put it in a vertex
    VertexArray va;

    VertexBuffer vb(poss, 4* 4 * sizeof(float));

    VertexBufferLayout layout;
    layout.Push(2,"float");
    layout.Push(2,"float");
    va.AddBuffer(vb,layout);    

    IndexBuffer ibo(SqIndex,6);

    
    Texture texture("assets/Textures/OtherBox.png");
    texture.Bind();

    Shader shader("assets/Shaders/ColorImg.shader");
    shader.Bind();

    

    // This has to match the bound texture buffer

    shader.SetUniform1i("u_Texture", 0);
    //shader.SetUniform4f("u_Color", 0.0f, 0.0f, 1.0f, 0.0f);

    Renderer renderer;


    glBindVertexArray(0);
    glUseProgram(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

    // This can be set once, it does not depend on shader

    const char *glsl_version = "#version 330 core";


    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO(); (void)io;

    ImGui::StyleColorsDark();
    //ImGui::StyleColorsClassic();

    // Setup Platform/Renderer backends
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init(glsl_version);

    bool show_demo_window = true;
    bool show_another_window = false;

    glm::vec3 posOff(100,100,0);
    glm::vec3 startPos(200,200,0);

    ImVec4 lineColor = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);


    test::Test* currentTest = nullptr;
    test::Test_Menu* menu = new test::Test_Menu(currentTest);
    currentTest = menu;

    menu->RegisterTest<test::TestClearColor>("Background Color");

    test::TestClearColor test;

    test.m_running = false;




   
    float R = 0.05;
    float inc = 0.005;
// Draw LOOP
    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {

        glfwPollEvents();
       
        /* Render here */
        renderer.Clear();

         // Start the Dear ImGui frame
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();


        // Set Shader, Draw Object
        //shader.SetUniform4f("u_Color", R, 0.0f, 0.0f, 1.0f );

        //GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));

        if(R > 1.0f){
            inc = -0.005f;
        } else if(R < 0.0f) {
            inc = 0.005f;
        }
        R += inc;

        glm::mat4 modle = glm::translate(glm::mat4(1.0f), posOff);
        glm::mat4 mvp = proj * view * modle;

        shader.SetUniformMat4f("u_MVP", mvp);

        //IMGUI EXAMPLE WINDOW

        {static float f = 0.0f;
        static int counter = 0;

        ImGui::Begin("Hello, world!");                          // Create a window called "Hello, world!" and append into it.

        ImGui::Text("This is some useful text.");               // Display some text (you can use a format strings too)
        ImGui::Checkbox("Demo Window", &show_demo_window);      // Edit bools storing our window open/close state
        ImGui::Checkbox("Another Window", &test.m_running);

        ImGui::SliderFloat3("Position", &posOff.x , 0.0f, 600.0f);            // Edit 1 float using a slider from 0.0f to 1.0f
        ImGui::ColorEdit3("Line Color", (float*)&lineColor); // Edit 3 floats representing a color

        if (ImGui::Button("Button"))                            // Buttons return true when clicked (most widgets return true when edited/activated)
            counter++;
        ImGui::SameLine();
        ImGui::Text("counter = %d", counter);

        ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);
        ImGui::End();}

        if (test.m_running)
        {
            test.OnUpdate(0.0f);
            test.OnRender();
            test.OnImGui();

        }

        shader.SetUniform4f("u_Color", lineColor.x, lineColor.y, lineColor.z, lineColor.w);

            //GLCall(glBindBuffer(GL_ARRAY_BUFFER, TryBuffer));
            // Convert to va.Bind()

        renderer.Draw(va,ibo,shader);

        glm::mat4 newmodle = glm::translate(glm::mat4(1.0f), startPos);
        glm::mat4 pvm = proj * view * newmodle;

        shader.SetUniformMat4f("u_MVP", pvm);

        renderer.Draw(va,ibo,shader);
        



        ImGui::Render();
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());


        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }



    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();

    shader.UnBind();


    glfwTerminate();
    return 0;
}
